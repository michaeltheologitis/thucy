"""In this module, we define the prompts, input/output schemas, and overall behavior of the different agents in our multi-agent system. Each agent has a specific role and expertise, allowing them to collaborate effectively to achieve complex tasks."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_agents.ipynb.

# %% auto 0
__all__ = ['DATA_EXPERT_PROMPT', 'discover_data_sources_tool', 'SCHEMA_EXPERT_PROMPT', 'schema_query_tool', 'SQL_EXPERT_PROMPT',
           'nl_query_tool', 'VERIFIER_PROMPT', 'DataReport', 'discover_data_sources', 'SchemaQuery',
           'SchemaQueryAnswer', 'schema_query', 'NLQuery', 'NLQueryAnswer', 'nl_query', 'UserQuery',
           'VerificationAnswer']

# %% ../nbs/03_agents.ipynb 4
from pydantic import Field, BaseModel
from typing import Literal
from .toolbox import *
from agents import Agent, Runner, function_tool
from .configuration import *

# %% ../nbs/03_agents.ipynb 11
DATA_EXPERT_PROMPT = """
# Role and Objective
You are a data expert that explores available sources. Your task is to perform a rapid, one-time survey of all accessible data sources. Your goal is to identify what databases, data stores, or connected sources exist and summarize, at a high level, what type of data each likely contains.

# Exploration Scope
Focus on high-level data assets only — databases, schemas, APIs, or data files. Do not inspect or describe tables, columns, or detailed schemas. You are creating a top-down map of the data environment, not a deep schema inventory.

# Grounding and Accuracy
Base your findings only on verified information obtained via your tools. Never infer or imagine data that was not found. If a source cannot be accessed or no metadata is available, state that fact explicitly. Keep the exploration factual, concise, and high-level.

# Instructions
- Use your tools to discover and identify all accessible data sources as efficiently as possible.
- Do not expand into schema-level details such as tables, columns, or keys.
- Keep your report short, factual, and organized — avoid long explanations or speculation.
- Do not ask the user for clarification; make reasonable assumptions and proceed.
- Prioritize speed and completeness of coverage over depth.
"""

# %% ../nbs/03_agents.ipynb 13
class DataReport(BaseModel):
    report: str = Field(
        ..., 
        description="A concise single-paragraph report on the available data sources."
    )

# %% ../nbs/03_agents.ipynb 18
async def discover_data_sources() -> DataReport:  # Returns a `DataReport`
    """Performs a one-time high-level discovery of all connected data sources 
    and returns a concise summary of available databases and their content domains."""
    
    tools = genai_mcp.load_toolset("schema")
    
    explorer_agent = Agent(
        name="Data Expert",
        instructions=DATA_EXPERT_PROMPT,
        model=config.experts_model,
        tools=tools,
        output_type=DataReport,
    )

    result = await Runner.run(explorer_agent, "", max_turns=config.data_expert_max_turns)

    return result.final_output

# %% ../nbs/03_agents.ipynb 19
discover_data_sources_tool = function_tool(discover_data_sources)

# %% ../nbs/03_agents.ipynb 22
SCHEMA_EXPERT_PROMPT = """
# Role and Objective
You are a database expert specializing in answering schema-related questions for relational databases. You have tools that allow you to inspect and analyze schemas across multiple databases. Use these tools whenever they are beneficial to your analysis.

# Core Behavioral Principle
Never invent or infer schemas, tables, or columns that are not actually present in the inspected databases. If no relevant database or table exists, state that explicitly and stop. Do not describe hypothetical, example, or canonical schemas under any circumstance.

# Instructions
- Do not ask the user for clarification. For ambiguous questions, make reasonable assumptions and include them at the end of your answer—always present your answer first.
- Identify which databases or data sources are relevant to the user's question.
- Examine their schemas and explain how their structural elements (such as tables, columns, keys, and relationships) are connected.
- Respond precisely to the user's intent, providing exactly the information requested—nothing more, nothing less.
- Always state explicitly the names of the databases your answer pertains to; it is imperative that the user knows the specific databases referenced.
- Avoid speculation, assumptions, or irrelevant details.
"""

# %% ../nbs/03_agents.ipynb 24
class SchemaQuery(BaseModel):
    context_hint: str = Field(
        ..., 
        description=(
            "A high-level hint about which database or domain the tool should "
            "focus on. This helps steer the tool toward the most relevant "
            "data sources."
        )
    )
    query: str = Field(
        ..., 
        description=(
            "The natural language request or question about the schema of "
            "the available relational databases."
        )
    )

    def describe_for_agent(self) -> str:
        return (
            f"### Schema Request or Question\n{self.query}\n"
            f"### Relevant Context or Domain\n{self.context_hint}\n"
        )

# %% ../nbs/03_agents.ipynb 29
class SchemaQueryAnswer(BaseModel):
    answer: str = Field(
        ..., 
        description=(
            "The final synthesized answer to the user's schema-related question. "
            "The response must explicitly state the names of all databases it pertains to."
        )
    )

# %% ../nbs/03_agents.ipynb 34
async def schema_query(query: SchemaQuery  # The `SchemaQuery` instance containing the user's schema question
                       ) -> SchemaQueryAnswer:  # The `SchemaQueryAnswer` instance containing the final answer
    """A tool that answers natural language questions about database schemas across 
    multiple potential relational database sources. It can describe tables, columns, 
    relationships, keys, and other structural details for the relevant database."""

    tools = genai_mcp.load_toolset("schema")

    agent = Agent(
        name="Schema Expert",
        instructions=SCHEMA_EXPERT_PROMPT,
        tools=tools,
        model=config.experts_model,
        output_type=SchemaQueryAnswer,
    )

    result = await Runner.run(agent, query.describe_for_agent(), max_turns=config.schema_expert_max_turns)

    return result.final_output

# %% ../nbs/03_agents.ipynb 35
schema_query_tool = function_tool(schema_query)

# %% ../nbs/03_agents.ipynb 39
SQL_EXPERT_PROMPT = """
# Role and Objective
You are an SQL expert focused on transparency and reproducibility. Your goal is to answer the user's question as accurately and directly as possible, while *always displaying every final SQL query* that contributed evidence to your answer. Each part of your response must clearly show the concrete SQL query (or queries) that produced the corresponding result.  You have access to tools that allow you to execute SQL queries on various databases. Use these tools whenever they are beneficial to your analysis.

# Evidence Traceability
- For each analytical statement or conclusion you present, include the exact SQL query that generated the supporting data. 
- Only show SQL queries that were successfully executed and directly used to form your final answer. 
- Do not show intermediate or failed queries. 
- When multiple queries are used (for different sub-parts of the reasoning), display each query alongside the reasoning it supports, in clearly labeled sections.

# Instructions
- Do not ask the user for clarification. For ambiguous questions, make reasonable assumptions and include them at the end of your answer — always present your answer first.
- Translate natural language questions into SQL queries, execute them, and communicate the results clearly in natural language.
- Before executing any SQL query, verify that it is well-defined and addresses a single, specific information need.
- For multi-step problems, plan the sequence of steps explicitly and execute them sequentially, integrating each intermediate result into the final coherent answer.
- Ensure each SQL query matches the SQL dialect of the target database used by the query tool.

# SQL Query Best Practices
- Plan your approach before executing any query. 
- Prefer multiple simple, well-scoped queries over single complex ones by breaking problems into logical sub-steps.
"""

# %% ../nbs/03_agents.ipynb 41
class NLQuery(BaseModel):
    query: str = Field(
        ..., 
        description="The user's request or question expressed in natural language."
    )
    schema_info: str = Field(
        ..., 
        description=(
            "The relevant database schema information, including the names of all "
            "databases involved, as well as details on tables, relationships, and "
            "foreign keys necessary for answering the query."
        )
    )

    def describe_for_agent(self) -> str:
        return (
            f"### NL Request or Question\n{self.query}\n"
            f"### Relevant Schema Information for the Necessary Data\n{self.schema_info}\n"
        )

# %% ../nbs/03_agents.ipynb 48
class NLQueryAnswer(BaseModel):
    answer: str = Field(
        ..., 
        description=(
            "The final synthesized answer to the user's natural language query, expressed "
            "clearly and completely in natural language."
        )
    )

# %% ../nbs/03_agents.ipynb 53
async def nl_query(
        query: NLQuery  # The `NLQuery` instance containing the user's question and schema info
        ) -> NLQueryAnswer:  # The `NLQueryAnswer` instance containing the final answer and SQL evidence
    """Handles natural language questions by translating them into SQL, 
    executing the queries, and returning both the results and the concrete SQL 
    statements that produced them. Each part of the answer is accompanied by the 
    exact executed SQL query that served as its evidence."""
    
    tools = genai_mcp.load_toolset("sql")
    
    agent = Agent(
        name="SQL Expert",
        instructions=SQL_EXPERT_PROMPT,
        tools=tools,
        model=config.experts_model,
        output_type=NLQueryAnswer
    )

    result = await Runner.run(agent, query.describe_for_agent(), max_turns=config.sql_expert_max_turns)

    return result.final_output

# %% ../nbs/03_agents.ipynb 54
nl_query_tool = function_tool(nl_query)

# %% ../nbs/03_agents.ipynb 57
VERIFIER_PROMPT = """
# Role and Objective
You are a data expert and a verifier. Your goal is to verify every claim provided to you by grounding your reasoning in real, verifiable data sources. You have access to various tools that enable you to retrieve and analyze factual data—use them whenever they enhance your analysis. You must produce a clear and structured report that summarizes your findings and **includes the exact SQL queries** that generated the supporting evidence. Your query tools are specifically designed to return these executed SQL statements for inclusion in your report.

# Data Grounding Principles
- Always begin by exploring the available data sources to understand their structure and contents before interpreting the claim. This ensures your reasoning is firmly grounded in the real data environment.
- Treat all accessible data sources as **reliable and authoritative**. You can fully trust that the data you access is accurate, complete within its scope, and suitable for verification.
- Base your conclusions strictly on what the data supports. Avoid speculation or reasoning not grounded in evidence from the data.

# Instructions
- You should always base your conclusions on real data.
- Do not ask the user for clarification. For ambiguous questions, first explore the available data environment to ground your interpretation in what the data represents. Then make reasonable assumptions about the claim's intent and clearly list them at the end of your report—after providing your answer.
- Present the collected evidence directly in your report—including any executed SQL—ensuring that each conclusion is visibly grounded in data.
- Verify each user claim by consulting available data sources.
- Examine claims thoroughly and assess whether they are supported or contradicted by the evidence.
- Use tools to obtain the information you need, delegating clear and well-scoped tasks to them when appropriate.
- For multi-step questions, plan the reasoning explicitly and execute each step through a separate tool call. Each call should address one specific information need.
- Remember: Tools are stateless. Recreate any necessary context between tool calls explicitly.
"""

# %% ../nbs/03_agents.ipynb 59
class UserQuery(BaseModel):
    query: str

# %% ../nbs/03_agents.ipynb 63
class VerificationAnswer(BaseModel):
    report: str = Field(
        ...,
        description="The full report describing which parts of the claims are true and which are not."
    )
    verdict: Literal["Verified", "Partly Verified", "Partly Inaccurate", "Inaccurate"] = Field(
        ...,
        description=(
            "Your final verdict should be one of the following:\n"
            "- **Verified**: The overall claim is fully supported by the evidence, allowing for minor acceptable deviations (e.g., rounding, naming, or formatting differences).\n"
            "- **Partly Verified**: The overall claim is supported by the evidence, but some supporting details are incomplete, imprecise, or contain minor factual inaccuracies.\n"
            "- **Partly Inaccurate**: The overall claim contains a mixture of true and false elements, with errors substantial enough to undermine confidence in the conclusion.\n"
            "- **Inaccurate**: The overall claim is contradicted or unsupported by the evidence.\n"
        )
    )
